#' Data upload
#'
#' Safely uploads data to be processed in DIETCOST software.
#' @param filepath The filepath in which the dataset, in .xlsx format, is saved.
#' @param sheet The sheet of the .xlsx to be read.
#' @return The dataframe generated by the file which was read.
#' @examples 
#' df <- upload_data('C:/Users/username/Downloads/dataset.xlsx', 'foods');
#' @export
upload_data <- function(filepath, sheet){
  df<- tryCatch(
    expr = {read_excel(filepath, sheet)},
    error = function(e){
      print('Upload failed!')
      stop(e)}
  )
  return(df)
}

#' Unique value check
#'
#' Checks if there are non-unique values in dataset.
#' @param value Column from which an unique vector will be formed.
#' @param df Dataframe in which lies the column to be checked.
#' @param value_col Name of the column to be checked, in string format.
#' @param value_name Name of the variable tested.
#' @examples 
#' unique_values(df$food_id,df,'food_id', "food ID");
#' @export
unique_values <- function(value, df, value_col, value_name){
  if(length(unique(value))<nrow(df)){
    duplicates = df %>% group_by(UQ(sym(value_col))) %>% summarise(n=n()) %>% filter(n>1)
    colnames(duplicates) <- c("value", "n")
    stop(paste("Check the data! There are duplicates!", duplicates$value))
  } else{
    print(paste('Only unique values:', value_name))
  }
}

#' Missing value check
#'
#' Checks if there are any missing values in a given column from the dataset.
#' @param name Column in which missing values will be sought.
#' @param column Column name, in string format.
#' @examples 
#' unique_values(df$food_id,"food ID");
#' @export
check_function <- function(name, column){
  if(any(is.na(name))){
    stop(paste('Missing',column,'! Check the food data!'))
  }
}

#' Sauces, protein and discretionary food groups treatment
#'
#' Treats above said food name groups to the format used in the package.
#' @param group Food group column in dataframe.
#' @return Treated dataframe.
#' @examples 
#'df$food_group <- sapply(df$food_group, sauces_protein_discretionary_change)
#' @export
sauces_protein_discretionary_change <- function(group){
  ifelse(group == 'Sauces, dressings, spreads, sugars',
         'Sauces',
         ifelse(grepl('Protein',group),
                'Protein',
                ifelse(group == ' Discretionary foods',
                       'Discretionary foods',
                       ifelse(grepl('starchy', group,ignore.case = TRUE), 'Starchy vegetables',group))))
}

#' Redmeat flag
#'
#' Sets a boolean redmeat flag column in dataset.
#' @param id Food group id column in dataframe.
#' @param redmeat_ids Vector of unique food IDs that are redmeat.
#' @examples 
#'df$redmeat <- sapply(df$food_id, redmeat_check, c(00001, 00002))
#' @export
redmeat_check <- function(id, redmeat_ids){
  ifelse(id %in% redmeat_ids,
         TRUE,
         FALSE)
}

#' Non-numeric check
#'
#' Checks if values supposed to be numeric are in fact numeric.
#' @param df Dataframe column.
#' @examples 
#'check_nom_num(df$food_id)
#' @export
check_non_num <- function(df) {
  bad_num <- is.na(suppressWarnings(as.numeric(as.character(df))))
  if(length(which(bad_num & !is.na(df)))>0) return(0) else return(1)
}

#' Applies non-nummeric value check to entire dataframe
#'
#' Checks if values supposed to be numeric are in fact numeric.
#' @param df Dataframe columns.
#' @examples 
#'check_nom_num_df(df)
#' @export
check_nom_num_df <- function(df){
  if(0 %in% lapply(df, check_non_num)){
    stop("Non-nummerical entries in nutrient targets dataset aren't allowed. Check your data!]")
  }
}

#' Variety check
#'
#' Checks if varieties are into the allowed range (1,2 or 3).
#' @param df Dataframe variety column.
#' @examples 
#'check_variety(df$variety)
#' @export
check_variety <- function(df){
  check_nom_num_df(df)
  if(max(df) > 3){
    stop('Allowed varieties: 1, 2 or 3 ')
  }
}

#' Standard name check
#'
#' Checks if variable names are the stadard defined into DIETCOST R standard table.
#' @param df Dataframe.
#' @examples 
#'standard_name_check(df, 'food_id', 'food_name')
#' @export
standard_name_check <- function(df,...){
  variables <- list(...)
  for(variable in variables){
    if(!(variable %in% colnames(df))){
      stop("Column names don't match standard. Check your data!")
    }
  }
}

#' Join function
#'
#' Safely performs a left join between two dataframes.
#' @param df1 First dataframe.
#' @param df2 Second dataframe.
#' @param condition Column in which the two datframes will be joined. Can be a single string or a vector.
#' @examples 
#'df <- join_function(df1,df2,'food_id');
#'df <- join_function(df1,df2,c('food_id','food_ID'));
#' @export
join_function <- function(df1, df2, condition){
  df <- df1 %>%
    tryCatch(
      expr = left_join(.,df2, by = condition),
      error = function(e){
        message('Join failed!')
        stop(e)
      }
    )
  return(df)
}

#' Food data creation
#'
#' Creates a food data dataframe
#' @param filepath Path in which the dataset, in .xlsx format, is stored.
#' @param redmeat_ids Vector of redmeat IDs.
#' @return Food dataframe.
#' @examples 
#' foods_df <- createFoodData(filepath = 'C:/Users/username/Downloads/dataset.xlsx', redmeat_ids = c(71003, 71008, 71041, 81005, 81021, 81022, 81026, 81027, 81029))
#' @export
createFoodData <- function(filepath, redmeat_ids){
  df <- upload_data(filepath, 'foods')
  standard_name_check(df, 'food_id', 'food_name', 'food_group', 'variety')
  unique_values(df$food_id,df,'food_id', "food ID")
  lapply(df$food_name, check_function, 'food names')
  check_variety(df$variety)
  df$food_group <- sapply(df$food_group, sauces_protein_discretionary_change)
  print("Food group names altered with success.")
  df$redmeat <- sapply(df$food_id, redmeat_check, redmeat_ids)
  print("Red meat flag added with success.")
  print('Food data dataframe created with success.')
  return(df)
}

#' Food group data creation
#'
#' Creates and populates a food group data dataframe
#' @param df Foods dataframe.
#' @return Food group dataframe.
#' @examples 
#' food_groups_df <- createFoodGroupData(foods_df);
#' @export
createFoodGroupData <- function(df){
  commonly_absent_groups <- c('Starchy vegetables', 'Alcohol', 'Discretionary foods', 'Takeaway')
  standard_name_check(df,'food_group', 'food_group_id')
  groups <- unique(df$food_group)
  for(i in 1:length(commonly_absent_groups)){
    if(!(commonly_absent_groups[i] %in% groups)){
      groups <- c(groups, commonly_absent_groups[i])
    }
  }
  fill_column_food_groups_df <- lapply(groups,function(group){
    food_group <- group
    
    data.frame(
      food_group
    )
  })
  food_groups_df <- do.call(rbind, fill_column_food_groups_df)
  rownames(food_groups_df) <- NULL
  food_groups_df <- join_function(food_groups_df, unique(df[,c('food_group', 'food_group_id')]),'food_group')
  food_groups_df <- food_groups_df[order(food_groups_df$food_group_id),]
  if(nrow(food_groups_df)>1){
    for(i in 1:nrow(food_groups_df)){
      if(is.na(food_groups_df$food_group_id[i])){
        food_groups_df$food_group_id[i] <- food_groups_df$food_group_id[i-1]+1
      }
    }
  }

  unique_values(food_groups_df$food_group_id, food_groups_df, 'food_group_id', "food group ID")
  print("Food group dataframe created with success.")
  return(food_groups_df)
}


#' Emission data addition
#'
#' Adds emission data to foods dataframe.
#' @param filepath Path in which the dataset, in .xlsx format, is stored.
#' @param df Foods dataframe.
#' @param emission_cols Optional parameter. Emission column names if standard dataset isn't used.
#' @return Food dataframe with emission data.
#' @examples 
#' foods_df <- addEmissionData(filepath = 'C:/Users/username/Downloads/dataset.xlsx', df = foods_df);
#' foods_df <- addEmissionData(filepath = 'C:/Users/username/Downloads/dataset.xlsx', df = foods_df, emission_cols = c('CO2','WF_l'));
#' @export
addEmissionData <- function(filepath, df, emission_cols = NULL){
  standard_name_check(df, 'food_id')
  df1 <- upload_data(filepath, 'emissions')
  if(is.null(emission_cols)){
    emission_cols <- c('CF_gCO2eq', 'WF_l', 'EF_g_m2')
  }
  cols <- c('food_id',emission_cols)
  for(i in 1:length(cols)){
    standard_name_check(df1, cols[i])
  }
  check_nom_num_df(df1[,(names(df1) %in% cols)])
  df <- join_function(df,df1[,cols],'food_id')
  print("Emission data added to food dataframe with success.")
  na_rows_emissions <-df[!complete.cases(df),]
  if(nrow(na_rows_emissions) > 0){
    lapply(na_rows_emissions$food_id, function(x) print(paste("ID",x,"is missing in emission sheets.")))
    stop("Check the data and rerun the application.")
  } else{
    print("All logged foods have emission data.")
  }
  return(df)
}

#' Spellcheck
#'
#' Checks if two datasets have the same spelling in names column.
#' @param df1 First dataframe.
#' @param df2 Second dataframe.
#' @param condition Column to be joined.
#' @examples 
#' check_spelling(foods_df, emission_df, 'food_id')
#' @export
check_spelling <- function(df1, df2, condition){
  df <- join_function(df1, df2, condition)
  df <- df %>% mutate(
    result = case_when(
      df$'food_name.x' == df$'food_name.y'~0,
      df$'food_name.x' != df$'food_name.y'~1
    )
  )
  
  if(any(df$result == 1)){
    df_e = df %>% filter(result == 1)
    for(i in 1:nrow(df_e)){
      e = paste("ID",df_e$'food_id'[i],"has distinct names in both sheets:",df_e$'food_name.x'[i],"and",df_e$'food_name.y'[i],".")
      print(e)
      if(i == nrow(df_e)){
        rm(df)
        rm(df_e)
        stop("Check the data and rerun the application.")
      }
    } 
    
  } else{
    print("No name mismatches between datasets.")
  }
  rm(df)
}

#' Pre-treatment of constraint data
#'
#' Pre-treatment of constraints dataframe.
#' @param df Dataframe to be treated.
#' @param min_identifier Minimum value column identifier. 'Min' in standard dataset.
#' @param max_identifier Maximum value column identifier. 'Max' in standard dataset.
#' @param suffix Suffix to be added to column name.
#' @param max_scale Maximum scale. Default is two.
#' @param max_scale Maximum scale. Default is two.
#' @param override_min If is not null, overrides all minimum values.
#' @return Treated dataframe.
#' @examples 
#' treat_df(df1,min, max, diet_suffix, max_scale, override_min)
#' @export
treat_df <- function(df, min_identifier, max_identifier, suffix, max_scale, override_min){
  df_max <- df[,grepl(max_identifier, names(df))] %>% replace(is.na(.), 0)
  df_max[] <- lapply(df_max, FUN = function(x) if (is.numeric(x)) return(x * 2 * max_scale) else return(x))
  df_id = df[,c('food_id','serve_size')]
  df_min <- df[,grepl(min_identifier, names(df))] %>% replace(is.na(.), 0)
  if (is.null(override_min)){
    df_min[] <- lapply(df_min, FUN = function(x) if (is.numeric(x)) return(x * 2) else return(x))
  } else{
    df_min[] <- lapply(df_min, FUN = function(x) x = override_min)
    print(paste("All food min overriden to", override_min))
  }
  df <- data.frame(cbind(df_id,df_min, df_max))
  col1 = 'serve_size'
  df <- df %>% rename_with(~paste0(.,suffix),UQ(sym(col1)):UQ(sym(colnames(df)[ncol(df)])))
  rm(df_max)
  rm(df_min)
  rm(df_id)
  return(df)
}

#' Float range
#'
#' Checks if a numeric variable is within a continuous float range.
#' @param variable Numeric variable.
#' @param min Minimum possible value.
#' @param max Maximum possible value.
#' @examples 
#' add_float_range(value, 0,100)
#' @export
add_float_range<- function(variable, min, max){
  if(variable<min || variable > max){
    stop(paste(variable, 'argument must be be between',min,'and',max))
  }
}

#' Discrete range
#'
#' Checks if a variable is within a discrete range.
#' @param variable variable.
#' @param range Allowed range.
#' @param message Message to be printed in case of failure.
#' @examples 
#' add__range(value, c('C','PF','H','PV'),'C, PF, H and PV')
#' @export
add_range <- function(variable, range, message){
  if(is.null(variable) || !length(variable) || !all(variable %in% range)){
    stop(paste("'",variable,"' argument must be one of:", message))
  }
}

#' Food constraint data addition
#'
#' Adds nutrients constraint data, according to chosen diet, to foods dataframe.
#' @param filepath Path in which the dataset, in .xlsx format, is stored..
#' @param df Foods dataframe.
#' @param diets Chosen diets. Constraint sheets in foods dataset must be of format 'constraints_DIETNAME_diet_foods', then the parameter passed will be DIETNAME. Can be a vector of diets in format c('DIETNAME1','DIETNAME2',...,'DIETNAMEN').
#' @param max_scale Maximum scale.
#' @param override_min If is not null, overrides all minimum values.
#' @return Foods dataframe with constraints columns.
#' @examples 
#' foods_df <- addConstraintData(filepath = 'C:/Users/username/Downloads/dataset.xlsx', df = foods_df, diet = c('C', 'PF', 'H'), max_scale = 2);
#' foods_df <- addConstraintData(filepath = 'C:/Users/username/Downloads/dataset.xlsx', df = foods_df, diet = c('C', 'PF', 'H'), max_scale = 2, override_min = 50);
#' @export
addConstraintData <- function(filepath, df, diets, max_scale, override_min = NULL){
  standard_name_check(df, 'food_id', 'food_name', 'food_group')
  for(i in 1:length(diets)){
    sheet <- paste0('constraints_',diets[i],'_diet_foods')
    min <- 'min'
    max <- 'max'
    diet_suffix <- paste0('_',diets[i])
    sheet <- paste0('constraints_',diets[i],'_diet_foods')
    df1 <- upload_data(filepath, sheet)
    standard_name_check(df1, 'food_id', 'food_name', 'serve_size')
    df1$food_group <- sapply(df1$food_group, sauces_protein_discretionary_change)
    lapply(df1$food_name, check_function, 'food names')
    check_spelling(df[,c('food_id', 'food_name')], df1[,c('food_id', 'food_name')],'food_id')
    df1 <- treat_df(df1,min, max, diet_suffix, max_scale, override_min) 
    check_nom_num_df(df1[,!(names(df1) %in% c('food_id', 'food_name', "food_group"))])
    df <- join_function(df, df1, 'food_id')
  }
  print('Food constraints added with success.')
  return(df)
}

#' ID mismatch check
#'
#' Checks if a given food has an ID assigned but is absent in another dataset.
#' @param df1 First dataframe.
#' @param df2 Second dataframe.
#' @param value Dataset name.
#' @examples 
#' check_id_defined(df1, df, 'nutrition')
#' @export
check_id_defined <- function(df1, df2, value){
  check_df <- df1 %>% filter(!(food_id %in% unique(df2$food_id))) %>% pull(food_id)
  if(length(check_df)>0){
    for(i in 1:length(check_df)){
      print(paste("ID",check_df[i],"has its ", value," defined but isn't present in food data."))
    }
    stop("Loading failed!")
  } else{
    print(paste("Every ID is accounted for."))
  }
}

#' Nutrients data addition
#'
#' Adds nutrients data to foods dataframe.
#' @param filepath Path in which the dataset, in .xlsx format, is stored..
#' @param df Foods dataframe.
#' @return Foods dataframe with nutrient columns.
#' @examples 
#' foods_df <- addNutrientData(filepath = 'C:/Users/username/Downloads/dataset.xlsx', df = foods_df);
#' @export
addNutrientData <- function(filepath, df){
  standard_name_check(df, 'food_id', 'food_name')
  df1 <- upload_data(filepath, 'nutrients')
  standard_name_check(df1,'food_id', 'food_name')
  check_nom_num_df(df1[,!(names(df1) %in% c('food_id', 'food_name'))])
  check_id_defined(df1, df, 'nutrition')
  check_spelling(df[,c('food_id', 'food_name')], df1[,c('food_id', 'food_name')],'food_id')
  df1 <- df1[,!(names(df1) %in% 'food_name')]
  df <- join_function(df, df1, 'food_id')
  print('Nutrients data added with success.')
  return(df)
}

#' Permitted individuals check
#'
#' Checks if logged individuals are one or all of the following: man, woman, boy or girl.
#' @param df Variable.
#' @examples 
#' permitted_individuals(data.frame(individual = person))
#' @export
permitted_individuals <- function(df){
  possible_individuals <- c('man', 'woman', 'boy','girl')
  check <- df %>% filter(!(individual %in% possible_individuals)) %>% pull(individual)
  if(length(check)>0){
    for(i in 1:length(check)){
      print(paste("Individual",check[i],"isn't allowed."))
    }
    stop("Check your data! The only possible individuals in standard table mode are 'man', 'woman', 'boy' and 'girl'.")
  }
}

#' Individual/diet mismatch check
#'
#' Checks if all individuals have a matching diet.
#' @param df Dataframe.
#' @examples 
#' check_match_individual_diet(df)
#' @export
check_match_individual_diet <- function(df){
  if(any(is.na(df$individual))){
    stop('There is a diet without a matching individual! Check your data.')
  }
  
  if(any(is.na(df$diet))){
    stop('There is an individual without a matching diet! Check your data.')
  }
  
}

#' MJ to KJ conversion
#'
#' Converts energy values in megajoules (MJ) to kilojoules (KJ),
#' @param df Dataframe.
#' @param min Minimum energy column name. Default 'energy_mj_min'.
#' @param max Maximum energy column name. Default 'energy_mj_max'.
#' @examples 
#' df <- energy_conversor(df, 'energy_mj_min', 'energy_mj_max')
#' @export
energy_conversor <- function(df, min, max){
  df <- df %>% mutate(
    across(
      .cols = c(grep(min, colnames(df)), grep(max, colnames(df))),
      .fns = function(x){
        x * 1000
      }
    )
  )
  names(df)[names(df) == min] <- "energy_kj_min"
  names(df)[names(df) == max] <- "energy_kj_max"
  return(df)
}

#' Optional food groups check
#'
#' If discretionary foods, alcohol or takeaway are permitted, looks for a minimum value and sets zero if missing,
#' @param check Boolean variable to permit optional food group.
#' @param value Minimum percentage of energy intake from optional food group.
#' @return Minimum percentage of energy intake from optional food group.
#' @examples 
#' alcohol <- checks_optional_food_groups(allow_alcohol, alcohol_perc_max)
#' @export
checks_optional_food_groups <- function(check, value){
  if(isTRUE(check)){
    if(is.null(value)){
      stop(paste("Please insert into function the following variable: "), deparse(substitute(value)))
    }
    add_float_range(value, 0,100)
  } else{
    value <- 0
  }
  return(value)
}

#' Minimum intake food groups check
#'
#' Looks for a minimum value and sets zero if missing,
#' @param df Dataframe.
#' @param check Boolean variable to permit optional food group.
#' @param col Minimum percentage intake column name.
#' @return Dataframe.
#' @examples 
#'  df <- check_min_exists(df, allow_alcohol, alcohol_perc_min)
#' @export
check_min_exists <- function(df, check, col){
  if(isTRUE(check) && !(col %in% colnames(df))){
    df[col] <- 0
  }
  return(df)
}

#' Nutrients data addition
#'
#' Adds nutrients data to foods dataframe.
#' @param filepath Path in which the dataset, in .xlsx format, is stored..
#' @param allow_alcohol Boolean variable checking if alcohol is permitted. Default TRUE.
#' @param allow_discretionary Boolean variable checking if discretionary foods are permitted. Default TRUE.
#' @param allow_takeaway Boolean variable checking if takeaway is permitted. Default TRUE.
#' @param alcohol_perc_max Optional parameter. Defines maximum energy intake derived from alcohol.
#' @param discretionary_perc_max Optional parameter. Defines maximum energy intake derived from discretionary foods.
#' @param takeaway_perc_max Optional parameter. Defines maximum energy intake derived from takeaway.
#' @return Nutrient targets dataframe.
#' @examples 
#' nutrient_targets <- createNutrientTargets(filepath = 'C:/Users/username/Downloads/dataset.xlsx', allow_takeaway = FALSE, alcohol_perc_max = 20, discretionary_perc_max = 100);
#' @export
createNutrientTargets <- function(filepath, allow_alcohol = TRUE, allow_discretionary = TRUE, allow_takeaway = TRUE, alcohol_perc_max = NULL, discretionary_perc_max = NULL, takeaway_perc_max = NULL){
  alcohol <- checks_optional_food_groups(allow_alcohol, alcohol_perc_max)
  discretionary <- checks_optional_food_groups(allow_discretionary, discretionary_perc_max)
  takeaway <- checks_optional_food_groups(allow_takeaway, takeaway_perc_max)
  df <- upload_data(filepath, 'nutrient_targets')
  standard_name_check(df,'individual', 'diet', 'energy_mj_min', 'energy_mj_max', 'alcohol_perc_max', 'discretionary_perc_max', 'takeaway_perc_max')
  possible_missing_cols <- c('alcohol_perc_min', 'discretionary_perc_min', 'takeaway_perc_min')
  checks <- c(allow_alcohol, allow_discretionary, allow_takeaway)
  for(i in 1:length(possible_missing_cols)){
    df <- check_min_exists(df, checks[i], possible_missing_cols[i])
  }
  df <- energy_conversor(df, 'energy_mj_min', 'energy_mj_max')
  df$alcohol_perc_max <- alcohol
  df$discretionary_perc_max <- discretionary
  df$takeaway_perc_max <- takeaway
  check_match_individual_diet(df)
  check_nom_num_df(df[,!(names(df) %in% c('individual', 'diet'))])
  df[,!(names(df) %in% c('individual', 'diet'))] <- df[,!(names(df) %in% c('individual', 'diet'))] %>% replace(is.na(.), 0)
  print('Nutrient targets data added with success.')
  return(df)
}

#' Food/price mismatch check
#'
#' Checks if all foods have a price.
#' @param df Dataframe.
#' @examples 
#' check_match_food_price(df1)
#' @export
check_match_food_price <- function(df){
  if(any(is.na(df$food_id))){
    stop('There is a food without an ID! Check your data.')
  }
  
  if(any(is.na(df$price))){
    stop('There is a food without a price! Check your data.')
  }
  
}

#' Price data addition
#'
#' Adds price data to foods dataframe.
#' @param filepath Path in which the dataset, in .xlsx format, is stored..
#' @param df Foods dataframe.
#' @return Foods dataframe with added price data.
#' @examples 
#' foods_df <- addPriceData(filepath = 'C:/Users/username/Downloads/dataset.xlsx', df = foods_df);
#' @export
addPriceData <- function(filepath, df){
  standard_name_check(df, 'food_id', 'food_name')
  df1 <- upload_data(filepath, 'prices')
  standard_name_check(df1, 'food_id', 'food_name', 'price')
  check_match_food_price(df1)
  check_id_defined(df1, df, 'price')
  check_nom_num_df(df1[,!(names(df1) %in% c('food_id', 'food_name'))])
  check_spelling(df[,c('food_id', 'food_name')], df1[,c('food_id', 'food_name')],'food_id')
  df <- join_function(df,df1[,c('food_id', 'price')],'food_id')
  print('Price data added with success.')
  return(df)
}

#' Treatment of food group constraints dataframe
#'
#' Converts weekly food group serves to daily and adds diet suffix to column names.
#' @param df Dataframe.
#' @param suffix Suffix to be added to column.
#' @return Treated food group dataframe.
#' @examples 
#' df <- treat_groups_df(df, 'C')
#' @export
treat_groups_df <- function(df, suffix){
  df <- df %>% replace(is.na(.), 0)
  df[] <- lapply(df, FUN = function(x) if (is.numeric(x)) return(x/7) else return(x))
  icol <- which(names(df) %in% 'food_group')
  colnames(df)[-icol] <- paste(colnames(df)[-icol],suffix,sep = '_')
  return(df)
}

#' Starchy vegetables serves addition
#'
#' Adds minimum and maximum serves of starchy vegetables.
#' @param df Dataframe.
#' @param starchy_name Starchy vegetables food group name. Default 'Starchy vegetables'.
#' @param serve_identifier Serve column identifier. Default 'serve'.
#' @param max_identifier Max column identifier. Default 'max'.
#' @return Food group dataframe with starchy vegetable minimum and maximum serves columns added.
#' @examples 
#' df <- starchy_fill(df, 'Starchy vegetables', 'serve', 'max')
#' @export
starchy_fill <- function(df,starchy_name, serve_identifier, max_identifier){
  row = which(df['food_group'] == starchy_name)
  for(column in which(grepl(serve_identifier,colnames(df))&grepl(max_identifier,colnames(df)))){
    if((is.numeric(df[row,column]) && df[row,column] == 0)||(is.na(df[row,column]))){
      df[row,column] <- 100
    }
  }
  return(df)
}

#' Food group constraint data addition
#'
#' Adds serves constraints to food groups dataframe
#' @param filepath Path in which the dataset, in .xlsx format, is stored..
#' @param df Food groups dataframe.
#' @param diets Chosen diets. Constraint sheets in foods dataset must be of format 'constraints_DIETNAME_diet_food_groups', then the parameter passed will be DIETNAME. Can be a vector of diets in format c('DIETNAME1','DIETNAME2',...,'DIETNAMEN').
#' @return Food groups dataframe with added constraint data.
#' @examples 
#' food_groups_df <- addFoodGroupsConstraintData(filepath = 'C:/Users/username/Downloads/dataset.xlsx', food_groups_df, diets = c('C','PF', 'H'));
#' @export
addFoodGroupsConstraintData <- function(filepath, df, diets){
  standard_name_check(df, 'food_group')
  for(i in 1:length(diets)){
    sheet <- paste0('constraints_',diets[i],'_diet_food_groups')
    df1 <- upload_data(filepath, sheet)
    standard_name_check(df1, 'food_group')
    check_nom_num_df(df1[,!(names(df1) %in% "food_group")])
    df1 <- treat_groups_df(df1, diets[i])
    df1['food_group'] <- sapply(df1['food_group'], sauces_protein_discretionary_change)
    df <- join_function(df,df1, 'food_group')
    df <- tryCatch(
      expr = starchy_fill(df, 'Starchy vegetables', 'serve', 'max'),
      error = function(e){
        message('Impossible to fill starchy vegetables serves with parameters informed. Please check your dataset and try again!')
        stop(e)
      }
    )
  }
  df[,!(names(df) %in% c('food_group', 'food_group_id'))] <- df[,!(names(df) %in% c('food_group', 'food_group_id'))] %>% replace(is.na(.), 0)
  print('Food group constraint data added with success.')
  return(df)
}

#' Single-function food dataframe creation
#'
#' Creates foods dataframe, with emission, nutrients, constraints and price data, in a single function.
#' @param filepath Path in which the dataset, in .xlsx format, is stored..
#' @param redmeat_ids Vector of unique food IDs that are redmeat.
#' @param diets Chosen diets. Constraint sheets in foods dataset must be of format 'constraints_DIETNAME_diet_foods', then the parameter passed will be DIETNAME. Can be a vector of diets in format c('DIETNAME1','DIETNAME2',...,'DIETNAMEN').
#' @param max_scale Maximum scale. Default is two.
#' @param emission_cols Optional parameter. Emission column names if standard dataset isn't used.
#' @param override_min If is not null, overrides all minimum values
#' @return Foods dataframe.
#' @examples 
#' foods_df <- foodData(filepath = 'C:/Users/username/Downloads/dataset.xlsx', redmeat_ids = c(71003, 71008, 71041, 81005, 81021, 81022, 81026, 81027, 81029), diets = c('C', 'PF', 'H'), max_scale = 2);
#' foods_df <- foodData(filepath = 'C:/Users/username/Downloads/dataset.xlsx', redmeat_ids = c(71003, 71008, 71041, 81005, 81021, 81022, 81026, 81027, 81029), diets = c('C', 'PF', 'H'), max_scale = 2, override_min = 50);
#' @export
foodData <- function(filepath = filepath, redmeat_ids, diets, max_scale, emission_cols = NULL, override_min = NULL){
  df <- createFoodData(filepath = filepath, redmeat_ids = redmeat_ids)
  df <- addEmissionData(filepath = filepath, df = df, emission_cols = emission_cols)
  for(i in 1:length(diets)){
    df <- addConstraintData(filepath = filepath, df = df, diet = diets[i], max_scale = max_scale, override_min = override_min)
  }
  df <- addNutrientData(filepath = filepath, df = df)
  df <- addPriceData(filepath = filepath, df = df)
  return(df)
}

#' Single-function food group dataframe creation
#'
#' Creates food groups dataframe, with constraints data, in a single function.
#' @param filepath Path in which the dataset, in .xlsx format, is stored.
#' @param df_foods Foods dataframe.
#' @param diets Chosen diets. Constraint sheets in foods dataset must be of format 'constraints_DIETNAME_diet_food_groups', then the parameter passed will be DIETNAME. Can be a vector of diets in format c('DIETNAME1','DIETNAME2',...,'DIETNAMEN').
#' @return Food groups dataframe.
#' @examples 
#' foods_df <- foodData(filepath = 'C:/Users/username/Downloads/dataset.xlsx', df_foods = foods_df, diets = c('C', 'PF', 'H'));
#' @export
foodGroupData <- function(filepath, df_foods, diets){
  df <- createFoodGroupData(foods_df)
  for(i in 1:length(diets)){
    df <- addFoodGroupsConstraintData(filepath = filepath, df, diets = diets[i])
  }
  return(df)
}

#' Safe sampling
#'
#' Safely extracts a random unitary sample from a vector.
#' @param x Vector.
#' @return Random sample.
#' @examples 
#'serve_range <- c(10,25,37,52,100);
#'foods_df$intake <- sample_safe(serve_range);
#' @export
sample_safe <- function(x) {
  if (length(x) <= 1) {
    return(x)
  } else {
    return(sample(x,1))
  }
}


#' Random deletion
#'
#' Randomly deletes a food.
#' @param df Dataframe.
#' @param column Column from which decision about removal of values will be made.
#' @param column Condition that, if is true, will enable radom removal.
#' @return Random meal plan
#' @examples 
#'foods_df <- random_plan(foods_df, 'food_group_id', discretionary_id)
random_plan <- function(df, column, condition){
  random_parameter <- 0.4
  for(i in 1:nrow(df)){
    if(unlist(df[i, column]) %in% condition){
      selector <- runif(1)
      if(selector > random_parameter){
        df <- df[-i,]
      }
    }
  }
  return(df)
}

#' Random meal plan
#'
#' Creates a random meal plan.
#' @param foods_df Foods dataframe.
#' @param targets_df Nutrient targets dataframe.
#' @param person Individual whose random meal plan will be created to. Can be one of man, woman, boy or girl.
#' @param diet Chosen diet. Must be DIETNAME from 'constraints_DIETNAME_diet_foods' sheet in dataset.
#' @param allowed_varieties Permitted food varieties. Can be a vector of the following: 1,2 and/or 3.
#' @param min_serve_size_difference Multiplier to serve difference. A float between 0 and 1.
#' @param allow_alcohol Boolean variable checking if alcohol is permitted. Default TRUE.
#' @param allow_discretionary Boolean variable checking if discretionary foods are permitted. Default TRUE.
#' @param allow_takeaway Boolean variable checking if takeaway is permitted. Default TRUE.
#' @param emission_cols Optional parameter. Emission column names if standard dataset isn't used.
#' @param nutrient_cols Optional parameter. Nutrients column names if standard dataset isn't used.
#' @return Random meal plan dataframe.
#' @examples 
#' foods_df <- createRandomMeal(foods_df = foods_df, targets_df = nutrient_targets, person = 'man', diet = 'C', allowed_varieties = c(1,2,3), min_serve_size_difference = 0.5, allow_takeaway = TRUE, allow_alcohol = TRUE, allow_discretionary = TRUE);
#' @export
createRandomMeal <- function(foods_df, targets_df, person, diet, allowed_varieties, min_serve_size_difference, allow_discretionary = TRUE, allow_alcohol = TRUE, allow_takeaway = TRUE, emission_cols = NULL, nutrient_cols = NULL){
  add_range(allowed_varieties,1:3,'1, 2, 3')
  permitted_individuals(data.frame(individual = person))
  add_float_range(min_serve_size_difference,0,1)
  serve_size <- paste0('serve_size_', diet)
  min <- paste0(person,'_min_',diet)
  max <- paste0(person,'_max_',diet)
  if(is.null(emission_cols)){
    emission_cols <- c('CF_gCO2eq', 'WF_l', 'EF_g_m2')
  }
  if(is.null(nutrient_cols)){
    nutrient_cols <- c('energy_kj_g', 'fat_g', 'sat_fat_g', 'CHO_g', 'sugars_g', 'fibre_g', 'protein_g', 'sodium_mg')
  }
  standard_name_check(foods_df, 'food_id', 'food_name', 'food_group_id', 'food_group', 'variety', 'redmeat', serve_size, min, max, 'price')
  for(i in 1:length(emission_cols)){
    standard_name_check(foods_df, emission_cols[i])
  }
  for(i in 1:length(nutrient_cols)){
    standard_name_check(foods_df, nutrient_cols[i])
  }
  alcohol_id <- ifelse('Alcohol' %in% foods_df$food_group,
                       unique(foods_df$food_group_id[foods_df$food_group == 'Alcohol']),
                              0)
  
  discretionary_id <- ifelse('Discretionary foods' %in% foods_df$food_group,
                             unique(foods_df$food_group_id[foods_df$food_group == 'Discretionary foods']),
                             0)
                       
  takeaway_id <- ifelse('Takeaway' %in% foods_df$food_group,
                        unique(foods_df$food_group_id[foods_df$food_group == 'Takeaway']),
                               0)

  diet_f <- diet
  targets_df <- targets_df %>% filter(diet == diet_f & individual == person)
  foods_df <- foods_df %>% filter(variety %in% allowed_varieties) %>% select(all_of('food_id'),
                                                                             all_of('food_name'),
                                                                             all_of('food_group_id'),
                                                                             all_of('food_group'),
                                                                             all_of('redmeat'),
                                                                             all_of(serve_size),
                                                                             all_of(min),
                                                                             all_of(max),
                                                                             all_of(emission_cols),
                                                                             all_of(nutrient_cols),
                                                                             all_of('price'))
  if(!isTRUE(allow_discretionary)||(isTRUE(allow_discretionary) && targets_df$discretionary_perc_max == 0) && ('Discretionary foods' %in% foods_df$food_group)){
    foods_df <- foods_df %>% filter(food_group_id != discretionary_id)
  }
  if(!isTRUE(allow_alcohol)||(isTRUE(allow_alcohol) && targets_df$alcohol_perc_max == 0) && ('Alcohol' %in% foods_df$food_group)){
    foods_df <- foods_df %>% filter(food_group_id != alcohol_id)
  }
  if(!isTRUE(allow_takeaway)||(isTRUE(allow_takeaway) && targets_df$takeaway_perc_max == 0) && ('Takeaway' %in% foods_df$food_group)){
    foods_df <- foods_df %>% filter(food_group_id != takeaway_id)
  }
  foods_df$intake <- double(nrow(foods_df))
  foods_df <- random_plan(foods_df, 'food_group_id', discretionary_id)
  foods_df <- random_plan(foods_df, 'food_group_id', alcohol_id)
  foods_df <- random_plan(foods_df, 'food_group_id', takeaway_id)
  for(i in 1:nrow(foods_df)){
    
    ifelse(unlist(foods_df[i,min])<=unlist(foods_df[i,max]),
           {
             serve_range <- seq(unlist(foods_df[i,min]), unlist(foods_df[i,max]), unlist(foods_df[i,serve_size])*min_serve_size_difference)
             foods_df$intake[i] <- sample_safe(serve_range) 
           },
           stop(paste("Check your data! Food ID",unlist(foods_df[i,'food_id']),"for",person,"with diet",diet,"has minimum serve size column higher than maximum."))
    )
  }
  names(foods_df) <- sapply(strsplit(as.character(names(foods_df)), paste0('_',diet)), `[[`, 1)
  names(foods_df)[names(foods_df) == paste0(person,'_max')] <- 'max'
  names(foods_df)[names(foods_df) == paste0(person,'_min')] <- 'min'
  foods_df$serves <- foods_df$intake/foods_df$serve_size
  return(foods_df)
}

#' Weekly conversion
#'
#' Converts data from daily to weekly
#' @param df Dataframe.
#' @param exclusion_cols Columns (non-numerical or percentage) that conversion won't be applied.
#' @return Weekly dataframe.
#' @examples
#'   individual_n <- grep('individual',colnames(df))
#'   diet_n <- grep('diet',colnames(df))
#'   percentage_n <- grep(percentage,colnames(df))
#'   exclusion_n <- c(individual_n,diet_n,percentage_n)
#'   df <- converts_dataframe(df, exclusion_n)
#' @export
converts_dataframe <- function(df, exclusion_cols){
  df <- tryCatch(
    expr = {
      df %>% mutate(
        across(
          .cols = -all_of(exclusion_cols),
          .fns = function(x){
            x*7
          }
        )
      )
    },
    error = function(e){
      print('Check your data! There are non-nummeric values in measures.')
      stop(e)
    }
  )
  return(df)
}

#' Suffix removal
#' 
#' Removes one of two suffixes from column names
#' @param vector Vector of column names
#' @param suffix_1 First suffix to be removed.
#' @param suffix_2 Second suffix to be removed.
#' @return Vector of column names without suffixes.
#' @examples
#'nutrient_names <- remove_suffix(nutrient_names, '_grams','_mgrams')
#' 
#' @export
remove_suffix <- function(vector, suffix_1, suffix_2){
  for(i in 1:length(vector)){
    drop <- ifelse(grepl(suffix_1,vector[i]),
                   suffix_1,
                   ifelse(grepl(suffix_2,vector[i]),
                          suffix_2,
                          'not'))
    
    if(drop != 'not'){
      vector[i] <- unlist(strsplit(vector[i],drop,1))
    }
    
  }
  return(vector)
}

#' Nutrient targets conversion
#' 
#' Converts nutrient targets dataframe to weekly values.
#' @param df Nutrient targets dataframe.
#' @param diet Chosen diet. Must be DIETNAME from 'constraints_DIETNAME_diet_foods' sheet in dataset.
#' @param person Individual whose random meal plan will be created to. Can be one of man, woman, boy or girl.
#' @param nutrient_constraints Optional parameter. Vector of nutrients column names to be used if not all nutrients are to be used as constraints.
#' @return Converted nutrient targets dataframe.
#' @examples
#' nutrient_targets_wk <- convertWeeklyNutrientTargets(nutrient_targets, 'C', 'man');
#' nutrient_targets_wk <- convertWeeklyNutrientTargets(nutrient_targets, 'C', 'man',c('energy','sodium'));
#' @export
convertWeeklyNutrientTargets <- function(df, diet, person, nutrient_constraints = NULL){
  permitted_individuals(data.frame(individual = person))
  min <- 'min'
  max <- 'max'
  percentage <- 'perc'
  serve <- 'serve'
  standard_name_check(df, 'individual', 'diet')
  df <- df[(df$diet == diet & df$individual == person),]
  serve_n <- grep(serve,colnames(df))
  if(length(serve_n) > 0){
    df <- subset(df,select = -serve_n)
  }
  individual_n <- grep('individual',colnames(df))
  diet_n <- grep('diet',colnames(df))
  percentage_n <- grep(percentage,colnames(df))
  exclusion_n <- c(individual_n,diet_n,percentage_n)
  df <- converts_dataframe(df, exclusion_n)
  cols_max <- grep('max',colnames(df))
  cols_min <- grep('min',colnames(df))
  nutrient_names <- unlist(strsplit(colnames(df[,cols_max]),'_max',1))
  nutrient_names <- remove_suffix(nutrient_names, '_grams','_mgrams')
  if('energy_kj' %in% nutrient_names){
    nutrient_names <- replace(nutrient_names, nutrient_names == 'energy_kj', 'energy')
  }
  df_targets <- data.frame(nutrient = nutrient_names,
                           min = double(length(nutrient_names)),
                           max = double(length(nutrient_names)))
  for(i in 1:nrow(df_targets)){
    df_targets$min[i] <- df[cols_min[i]]
    df_targets$max[i] <- df[cols_max[i]]
  }
  if(!is.null(nutrient_constraints)){
    for(i in 1:length(nutrient_constraints)){
      drop <- ifelse(grepl('_kj_g',nutrient_constraints[i]),
                     '_kj_g',
                     ifelse(grepl('_kj', nutrient_constraints[i]),
                            '_kj',
                            ifelse(grepl('_g',nutrient_constraints[i]),
                                   '_g',
                                   ifelse(grepl('_grams',nutrient_constraints[i]),
                                          '_grams',
                                          ifelse(grepl('_mg',nutrient_constraints[i]),
                                                 '_mg',
                                                 ifelse(grepl('_mgrams', nutrient_constraints[i]),
                                                        '_mgrams',
                                                        ifelse(grepl('_max',nutrient_constraints[i]),
                                                               '_max',
                                                               ifelse(grepl('_min', nutrient_constraints[i]),
                                                                      '_min',
                                                                      ifelse(grepl(paste0('_',person),nutrient_constraints[i]),
                                                                             paste0('_',person),
                                                                             ifelse(grepl(paste0('_',diet),nutrient_constraints[i]),
                                                                                    paste0('_',diet),
                                                                                    'not'))))))))))
      if(drop != 'not'){
        nutrient_constraints[i] <- unlist(strsplit(nutrient_constraints[i],drop,1))
      }
      if(!(nutrient_constraints[i] %in% df_targets$nutrient)){
        stop(paste(nutrient_constraints[i],"isn't listed in constraints. Check your data!"))
      }
    }
    df_targets <- df_targets[df_targets$nutrient %in% nutrient_constraints,]
  }
  return(df_targets)
}

#' Food group serves conversion
#' 
#' Converts food group serves dataframe to weekly values.
#' @param df Food group serves dataframe.
#' @param diet Chosen diet. Must be DIETNAME from 'constraints_DIETNAME_diet_food_groups' sheet in dataset.
#' @param person Individual whose random meal plan will be created to. Can be one of man, woman, boy or girl.
#' @return Converted food group serves dataframe.
#' @examples
#' food_groups_wk <- convertWeeklyFoodGroups(food_groups_df, 'C', 'man');
#' @export
convertWeeklyFoodGroups <- function(df, diet, individual){
  min <- paste0(individual,'_min_serve_',diet)
  max <- paste0(individual,'_max_serve_',diet)
  standard_name_check(df, 'food_group', 'food_group_id', min, max)
  df <- df %>% select(all_of('food_group_id'),
                      all_of('food_group'),
                      all_of(min),
                      all_of(max))
  id_n <- grep('food_group_id', colnames(df))
  group_n <- grep('food_group', colnames(df))
  exclusion_n <- c(id_n, group_n)
  df <- converts_dataframe(df, exclusion_n)
  names(df)[names(df) == min] <- 'min'
  names(df)[names(df) == max] <- 'max'
  return(df)
}

#' Percentage values calculator
#' 
#' Calculates percentage nutrient values.
#' @param df_nutri Nutrient constraints dataframe.
#' @param df_meal Random meal plan
#' @return Percentage dataframe.
#' @examples
#' df <- getPerc(getNutrients(random_meal),random_meal);
#' 
#' @export
getPerc <- function(df_nutri, df_meal){
  f1 <- 37.7
  f2 <- 16.7
  alcohol_id <- ifelse('Alcohol' %in% df_meal$food_group,
                       unique(df_meal$food_group_id[df_meal$food_group == 'Alcohol']),
                       0)
  discretionary_id <- ifelse('Discretionary foods' %in% df_meal$food_group,
                             unique(df_meal$food_group_id[df_meal$food_group == 'Discretionary foods']),
                             0)
  takeaway_id <- ifelse('Takeaway' %in% df_meal$food_group,
                        unique(df_meal$food_group_id[df_meal$food_group == 'Takeaway']),
                        0)
  if('fat' %in% df_nutri$nutrient && 'energy' %in% df_nutri$nutrient){
    df_nutri[nrow(df_nutri)+1,] <- c('fat_perc',(as.numeric(df_nutri$value[df_nutri$nutrient == 'fat'])*f1/as.numeric(df_nutri$value[df_nutri$nutrient == 'energy']))*100)
  }
  
  if('sat_fat' %in% df_nutri$nutrient && 'energy' %in% df_nutri$nutrient){
    df_nutri[nrow(df_nutri)+1,] <- c('sat_fat_perc',(as.numeric(df_nutri$value[df_nutri$nutrient == 'sat_fat'])*f1/as.numeric(df_nutri$value[df_nutri$nutrient == 'energy']))*100)
  }
  
  if('CHO' %in% df_nutri$nutrient && 'energy' %in% df_nutri$nutrient){
    df_nutri[nrow(df_nutri)+1,] <- c('CHO_perc',(as.numeric(df_nutri$value[df_nutri$nutrient == 'CHO'])*f2/as.numeric(df_nutri$value[df_nutri$nutrient == 'energy']))*100)
  }
  
  if('protein' %in% df_nutri$nutrient && 'energy' %in% df_nutri$nutrient){
    df_nutri[nrow(df_nutri)+1,] <- c('protein_perc',(as.numeric(df_nutri$value[df_nutri$nutrient == 'protein'])*f2/as.numeric(df_nutri$value[df_nutri$nutrient == 'energy']))*100)
  }
  
  if('sugars' %in% df_nutri$nutrient && 'energy' %in% df_nutri$nutrient){
    df_nutri[nrow(df_nutri)+1,] <- c('sugars_perc',(as.numeric(df_nutri$value[df_nutri$nutrient == 'sugars'])*f2/as.numeric(df_nutri$value[df_nutri$nutrient == 'energy']))*100)
  }
  
  if(alcohol_id != 0 && 'energy' %in% df_nutri$nutrient){
    df_nutri[nrow(df_nutri)+1,] <- c('alcohol_perc',(sum(df_meal$energy_kj_g[df_meal$food_group_id == alcohol_id])/as.numeric(df_nutri$value[df_nutri$nutrient == 'energy']))*100)
  }
  
  if(discretionary_id != 0 && 'energy' %in% df_nutri$nutrient){
    df_nutri[nrow(df_nutri)+1,] <- c('discretionary_perc',(sum(df_meal$energy_kj_g[df_meal$food_group_id == discretionary_id])/as.numeric(df_nutri$value[df_nutri$nutrient == 'energy']))*100)
  }
  
  if(takeaway_id != 0 && 'energy' %in% df_nutri$nutrient){
    df_nutri[nrow(df_nutri)+1,] <- c('takeaway_perc',(sum(df_meal$energy_kj_g[df_meal$food_group_id == takeaway_id])/as.numeric(df_nutri$value[df_nutri$nutrient == 'energy']))*100)
  }
  return(df_nutri)
}

#' Nutrients values calculator
#' 
#' Calculates nutritional value of meal plan.
#' @param df Random meal plan.
#' @param nutrient_cols Optional parameter. Vector of nutrients column names to be used if nutrients are different from standard dataset.
#' @return Nutrients dataframe.
#' @examples
#' df <- getPerc(getNutrients(random_meal),random_meal);
#' 
#' @export
getNutrients <- function(df, nutrient_cols = NULL){
  if(is.null(nutrient_cols)){
    nutrient_cols <- c('energy_kj_g','fat_g','sat_fat_g','CHO_g','sugars_g','fibre_g','protein_g','sodium_mg')
  }
  for(i in 1:length(nutrient_cols)){
    standard_name_check(df,nutrient_cols[i])
  }
  standard_name_check(df, 'intake', 'serves', 'redmeat', 'food_id', 'food_name', 'food_group', 'food_group_id')
  
  col_n <- integer(length(nutrient_cols))
  suppressWarnings(for(i in 1:length(nutrient_cols)){
    col_n[i] <- grep(nutrient_cols[i], colnames(df))
  })
  
  df <- tryCatch(
    expr = {
      df %>% mutate(
        across(
          .cols = all_of(col_n),
          .fns = function(x){
            (x/100)*df$intake
          }
        )
      )
    },
    error = function(e){
      print('Check your data!')
      stop(e)
    }
  )
  
  nutrient_names <- remove_suffix(nutrient_cols,'_g','_mg')
  if('energy_kj' %in% nutrient_names){
    nutrient_names <- replace(nutrient_names, nutrient_names == 'energy_kj', 'energy')
  }
  nutrients <- data.frame(nutrient = nutrient_names,
                          value = double(length(nutrient_names)))
  for(i in 1:nrow(nutrients)){
    nutrients$value[i] <- sum(df[,col_n[i]])
  }
  nutrients[nrow(nutrients) + 1,] <- c('redmeat',sum(df$intake[df$redmeat == TRUE]))
  
  return(nutrients)
}

#' Food group serves calculator
#' 
#' Calculates total food group serves of random meal plan.
#' @param df Random meal plan.
#' @return Food group serves dataframe.
#' @examples
#' serves <- getFoodGroupServes(random_meal);
#' 
#' @export
getFoodGroupServes <- function(df){
  standard_name_check(df, 'food_group', 'food_group_id', 'serves')
  
  df_serves <- df %>% summarise(value = sum(serves),
                                .by = c(food_group, food_group_id))
  return(df_serves)
}

#' Difference calculator
#' 
#' Calculates difference between values of random meal plan created and targets logged.
#' @param val Value to be evalueted.
#' @param min Minimum constraint.
#' @param max Maximum constraint.
#' @return Difference.
#' @examples
#' df$diff <- diff_calc(as.numeric(df$value), as.numeric(df$min), as.numeric(df$max));
#' 
#' @export
diff_calc <- function(val, min, max){
  res <- ifelse((val < min),
                {val - min},
                ifelse((val > max),
                       {val - max},
                       0))
  return(res)
}

#' General difference calculation
#' 
#' Applies difference calculation to entire dataset.
#' @param df_target Constraints dataframe.
#' @param df_nutrients Nutrients/serves from random meal plan dataframe.
#' @param merge_col Column to join both dataframes.
#' @return Differences dataframe.
#' @examples
#' nutrients_diff <- getDifference(df_target = nutrient_targets_wk, df_nutrients = nutrients_plan, merge_col = 'nutrient');
#' 
#' @export
getDifference <- function(df_target, df_nutrients, merge_col){
  for(i in 1:length(merge_col)){
    standard_name_check(df_target, merge_col[i])
    standard_name_check(df_nutrients, merge_col[i])
  }
  df <- left_join(df_target, df_nutrients, merge_col)
  df <- na.omit(df)
  for(i in 1:nrow(df)){
    df$diff[i] <- diff_calc(as.numeric(df$value[i]), as.numeric(df$min[i]), as.numeric(df$max[i]))
  }
  df <- df[,-which(names(df) %in% c('min', 'max', 'value'))]
  names(df)[names(df) == 'diff'] <- 'value'
  return(df)
}

#' Linked foods check
#' 
#' Checks if lower bound linked foods serves are lower or equal to higher bound linked foods serves.
#' @param df Random meal plan.
#' @param low Vector of lower bound food IDs.
#' @param high Vector of higher bound food IDs.
#' @return Differences dataframe.
#' @examples
#' linked_milk_low <- c("69029", "79012", "70038", "69043");
#' linked_milk_high <- c("79020", "79001", "79036", "79003", "79039");
#' link_sum_1 <- checkLinkedFoods(random_meal, linked_milk_low, linked_milk_high);
#' 
#' @export
checkLinkedFoods <- function(df, low, high){
  standard_name_check(df, 'food_id', 'serves')
  ls <- 0
  hs <- 0
  for(i in 1:length(low)){
    ls <- ifelse((low[i] %in% df$food_id),
                 {ls + df$serves[df$food_id == low[i]]},
                 ls)
  }
  for(i in 1:length(high)){
    hs <- ifelse((high[i] %in% df$food_id),
                 {hs + df$serves[df$food_id == high[i]]},
                 hs)
  }
  net <- hs - ls
  return(net)
}

#' All zero difference check
#' 
#' Checks if differences dataframe is all zeroes.
#' @param diff Differences dataframe
#' @return Boolean. TRUE if all zeroes, FALSE otherwise.
#' @examples
#' checkZeroDiff(nutrients_diff)
#' 
#' @export
checkZeroDiff <- function(diff){
  if(all(diff$value == 0)) return(TRUE) else return(FALSE)
}

#' Price/emission data application to random meal plan created
#'
#' Applies price and emission data calculation to random meal plan generated.
#'
#' @param df Random meal plan.
#' @param emission_cols Optional parameter. Emission column names if standard dataset isn't used.
#' @return Random meal plan with price and emissions calculated.
#' @examples
#' df <-priceEmissionData(meal_plan);
#' df <-priceEmissionData(meal_plan, c('CO2','WF_l'));
#' @export
#Apply price and emission data to food intake
priceEmissionData <- function(df, emission_cols = NULL){
  standard_name_check(df, 'price', 'intake')
  if(is.null(emission_cols)){
    emission_cols <- c('CF_gCO2eq', 'WF_l', 'EF_g_m2')
  }
  for(i in 1:length(emission_cols)){
    standard_name_check(df, emission_cols[i])
    df[emission_cols[i]] <- (df[emission_cols[i]]/1000)*df$intake
  }
  df$price <- (df$price/100)*df$intake
  return(df)
}

#' Monte Carlo simulation
#' 
#' Creates a Monte Carlo simulation to a given number of iterations. A hit meal consists of one that returnz zero difference between nutrient targets and random meal plan, food groups serves and respects lower linked foods serves lower or equal to higher linked foods serves, if existent.
#' @param iterations Number of iterations. Integer.
#' @param foods_df Foods dataframe.
#' @param nutrient_targets_df Nutrient constraints dataframe.
#' @param food_group_targets_df Food group serves dataframe.
#' @param person Individual whose random meal plan will be created to. Can be one of man, woman, boy or girl.
#' @param diet Chosen diet. Must be DIETNAME from 'constraints_DIETNAME_diet_foods' sheet in dataset.
#' @param allowed_varieties Permitted food varieties. Can be a vector of the following: 1,2 and/or 3.
#' @param min_serve_size_difference Multiplier to serve difference. A float between 0 and 1.
#' @param allow_alcohol Boolean variable checking if alcohol is permitted. Default TRUE.
#' @param allow_discretionary Boolean variable checking if discretionary foods are permitted. Default TRUE.
#' @param allow_takeaway Boolean variable checking if takeaway is permitted. Default TRUE.
#' @param emission_cols Optional parameter. Emission column names if standard dataset isn't used.
#' @param nutrient_cols Optional parameter. Nutrients column names if standard dataset isn't used.
#' @param nutrient_constraints Optional parameter. Vector of nutrients column names to be used if not all nutrients are to be used as constraints.
#' @param linked_low_1 Optional parameter. Vector of lower bound food IDs.
#' @param linked_high_1 Optional parameter. Vector of higher bound food IDs.
#' @param linked_low_2 Optional parameter. Vector of lower bound food IDs.
#' @param linked_high_2 Optional parameter. Vector of higher bound food IDs.
#' @return List of dataframes, containing results of simulation.
#' @examples
#' results <- monteCarlo(iterations, foods_df, nutrient_targets_df, food_group_targets_df, person, diet, allowed_varieties, min_serve_size_difference, allow_discretionary, allow_alcohol, allow_takeaway, emission_cols, nutrient_cols, nutrient_constraints, linked_low_1, linked_high_1, linked_low_2, linked_high_2)
#' 
#' @export
monteCarlo <- function(iterations, foods_df, nutrient_targets_df, food_group_targets_df, person, diet, allowed_varieties, min_serve_size_difference, allow_discretionary = TRUE, allow_alcohol = TRUE, allow_takeaway = TRUE, emission_cols = NULL, nutrient_cols = NULL, nutrient_constraints = NULL, linked_low_1 = NULL, linked_high_1 = NULL, linked_low_2 = NULL, linked_high_2 = NULL){
  if(round(iterations) != iterations || iterations <= 0){
    stop('Iterations must be a positive integer!')
  }
  abs_path <- paste0(getwd(), '/')
  new_dir <- paste0('results_', format(Sys.time(), '%Y%m%d%H%M%S'))
  dir.create(paste0(abs_path, new_dir))
  hash_list <- list()
  
  meal_plan <- createRandomMeal(foods_df = foods_df, targets_df = nutrient_targets_df, person = person, diet = diet, allowed_varieties = allowed_varieties, min_serve_size_difference = min_serve_size_difference, allow_takeaway = allow_takeaway, allow_alcohol = allow_alcohol, allow_discretionary = allow_discretionary, emission_cols = emission_cols, nutrient_cols = nutrient_cols)
  print(paste('All meals formed will be saved as .csv files in directory', paste0(abs_path, new_dir)))
  for(i in 1:iterations){
    nutrients_plan <- getPerc(getNutrients(df = meal_plan, nutrient_cols = nutrient_cols),meal_plan)
    serves_plan <- getFoodGroupServes(df = meal_plan)
    nutrient_targets_wk <- convertWeeklyNutrientTargets(nutrient_targets, diet = diet, person = person, nutrient_constraints = nutrient_constraints)
    food_groups_wk <- convertWeeklyFoodGroups(food_groups_df, diet = diet, individual = person)
    nutrients_diff <- getDifference(df_target = nutrient_targets_wk, df_nutrients = nutrients_plan, merge_col = 'nutrient')
    serves_diff <- getDifference(df_target = food_groups_wk, df_nutrients = serves_plan, merge_col = ,c('food_group','food_group_id'))
    off_measures <- NULL
    off_food_groups <- NULL
    off_linked_foods_low <- NULL
    off_linked_foods_high <- NULL
    target_measure <- NULL
    target_fg <- NULL
    serve_range <- NULL
    food <- NULL
    
    if((!is.null(linked_low_1)) && (!is.null(linked_high_1)) && (is.null(linked_low_1)) && (is.null(linked_low_1))){
      linked_sum_1 <- checkLinkedFoods(df = meal_plan, low = linked_low_1, high = linked_high_1)
    }
    if((!is.null(linked_low_1)) && (!is.null(linked_high_1)) && (!is.null(linked_low_1)) && (!is.null(linked_low_1))){
      linked_sum_1 <- checkLinkedFoods(df = meal_plan, low = linked_low_1, high = linked_high_1)
      linked_sum_2 <- checkLinkedFoods(df = meal_plan, low = linked_low_2, high = linked_high_2)
    }
    if(i == 1){
      iterations_constraints = data.frame(nutrient = nutrients_diff$nutrient,
                                          high = integer(nrow(nutrients_diff)),
                                          low = integer(nrow(nutrients_diff)))
      
      iterations_fg = data.frame(food_group = serves_diff$food_group,
                                 food_group_id = serves_diff$food_group_id,
                                 high = integer(nrow(serves_diff)),
                                 low = integer(nrow(serves_diff)))
      
      if((is.null(linked_low_1)) && (is.null(linked_high_1)) && (is.null(linked_low_1)) && (is.null(linked_low_1))){
        iterations_lk <- data.frame(link = 'no_link')
      }
      
      if((!is.null(linked_low_1)) && (!is.null(linked_high_1)) && (is.null(linked_low_1)) && (is.null(linked_low_1))){
        iterations_lk <- data.frame(link = 'pair_1',
                                    high = integer(1),
                                    low = integer(1))
      }
      if((!is.null(linked_low_1)) && (!is.null(linked_high_1)) && (!is.null(linked_low_1)) && (!is.null(linked_low_1))){
        iterations_lk <- data.frame(link = c('pair_1', 'pair_2'),
                                    high = integer(2),
                                    low = integer(2))
      }
      
    }
    print(paste('Iteration:',i))
    
    if(isTRUE(checkZeroDiff(nutrients_diff))){
      if(isTRUE(checkZeroDiff(serves_diff))){
        if((is.null(linked_low_1) && is.null(linked_high_1) && is.null(linked_low_2) && is.null(linked_high_2))||(!is.null(linked_low_1) && !is.null(linked_high_1) && is.null(linked_low_2) && is.null(linked_high_2) && linked_sum_1 >=0)||(!is.null(linked_low_1) && !is.null(linked_high_1) && !is.null(linked_low_2) && !is.null(linked_high_2) && linked_sum_1 >=0 && linked_sum_2 >=0)){
          print('Hit!')
          hash_diet <- hash(meal_plan)
          if(!(hash_diet %in% hash_list)){
            hash_list[[length(hash_list)+1]] <- hash_diet
            print('Unique diet formed!')
            write.csv(meal_plan, paste0(abs_path, new_dir, '/','meal_plan_',i,'.csv'), row.names=FALSE)
          } else{
            print('Diet already logged in!')
          }
          food = sample_safe(meal_plan$food_id)
          serve_range <- sort(seq(meal_plan$min[meal_plan$food_id == food], meal_plan$max[meal_plan$food_id == food], meal_plan$serve_size[meal_plan$food_id == food]*min_serve_size_difference))
        } else{
          if(!is.null(linked_low_1) && !is.null(linked_high_1) && is.null(linked_low_2) && is.null(linked_high_2) && linked_sum_1 < 0){
            off_linked_foods_low <- linked_low_1
            off_linked_foods_high <- linked_high_1
          } else{
            if(linked_sum_1 < 0 && linked_sum_2 < 0){
              off_linked_foods_low <- c(linked_low_1, linked_low_2)
              off_linked_foods_high <- c(linked_high_1, linked_high_2)
            } else if(linked_sum_1 < 0 && linked_sum_2 >= 0){
              off_linked_foods_low <- linked_low_1
              off_linked_foods_high <- linked_high_1
            } else if(linked_sum_1 >= 0 && linked_sum_2 < 0){
              off_linked_foods_low <- linked_low_2
              off_linked_foods_high <- linked_high_2
            }
          }
          if(length(off_linked_foods_low) > 0 && length(off_linked_foods_high) > 0){
            direction_choices <- c('<', '>')
            direction <- sample_safe(direction_choices)
            if(direction == '<'){
              tmp <- meal_plan$food_id[meal_plan$food_id %in% off_linked_foods_low]
              food <- sample_safe(tmp)
              if(food %in% linked_low_1){
                fl <- 'pair_1'
              } else{
                fl <- 'pair_2'
              }
              serve_range <- sort(seq(meal_plan$min[meal_plan$food_id == food], meal_plan$intake[meal_plan$food_id == food], meal_plan$serve_size[meal_plan$food_id == food]*min_serve_size_difference))
              print(paste0(c(paste0('Food link ', fl, ' is off. ', meal_plan$food_name[meal_plan$food_id == food], ' affects it at lower half. Current intake is ',meal_plan$intake[meal_plan$food_id == food], ' and it must be between ', meal_plan$min[meal_plan$food_id == food], ' and ', meal_plan$max[meal_plan$food_id == food],'. Options: '),serve_range), collapse = " "))
              iterations_lk$low[iterations_lk$link == fl] <- iterations_lk$low[iterations_lk$link == fl] + 1
            } else{
              tmp <- meal_plan$food_id[meal_plan$food_id %in% off_linked_foods_high]
              food <- sample_safe(tmp)
              if(food %in% linked_high_1){
                fl <- 'pair_1'
              } else{
                fl <- 'pair_2'
              }
              serve_range <- sort(seq(meal_plan$intake[meal_plan$food_id == food], meal_plan$max[meal_plan$food_id == food], meal_plan$serve_size[meal_plan$food_id == food]*min_serve_size_difference))
              print(paste0(c(paste0('Food link ', fl, ' is off. ', meal_plan$food_name[meal_plan$food_id == food], ' affects it at upper half. Current intake is ',meal_plan$intake[meal_plan$food_id == food], ' and it must be between ', meal_plan$min[meal_plan$food_id == food], ' and ', meal_plan$max[meal_plan$food_id == food],'. Options: '),serve_range), collapse = " "))
              iterations_lk$high[iterations_lk$link == fl] <- iterations_lk$high[iterations_lk$link == fl] + 1
            }
          }
        }
        
      } else{
        off_food_groups <- serves_diff[serves_diff$value != 0,]
        target_fg <- sample_safe(off_food_groups$food_group_id)
        
        foods_impacted <- meal_plan$food_id[meal_plan$food_group_id == target_fg]
        if(length(foods_impacted) == 0){
          print(paste('No food impact group:',target_fg))
          next
        }
        food <- sample_safe(foods_impacted)
        fg <- meal_plan$food_group[meal_plan$food_id == food]
        if(off_food_groups$value[off_food_groups$food_group_id == target_fg] > 0){
          print(paste0('Food group ', fg, ' has too many serves. Current: ', serves_plan$value[serves_plan$food_group_id == target_fg],'. Max: ', food_groups_wk$max[food_groups_wk$food_group_id == target_fg]))
          serve_range <- sort(seq(meal_plan$min[meal_plan$food_id == food], meal_plan$intake[meal_plan$food_id == food], meal_plan$serve_size[meal_plan$food_id == food]*min_serve_size_difference))
          iterations_fg$high[iterations_fg$food_group_id == target_fg] <- iterations_fg$high[iterations_fg$food_group_id == target_fg] + 1
        } else{
          print(paste0('Food group ', fg, ' has too few serves. Current: ', serves_plan$value[serves_plan$food_group_id == target_fg],'. Min: ', food_groups_wk$min[food_groups_wk$food_group_id == target_fg]))
          serve_range <- sort(seq(meal_plan$intake[meal_plan$food_id == food], meal_plan$max[meal_plan$food_id == food], meal_plan$serve_size[meal_plan$food_id == food]*min_serve_size_difference))
          iterations_fg$low[iterations_fg$food_group_id == target_fg] <- iterations_fg$low[iterations_fg$food_group_id == target_fg] + 1
        }
        print(paste0(c(paste0(meal_plan$food_name[meal_plan$food_id == food]," has current intake of ",meal_plan$intake[meal_plan$food_id == food]," and it must be between ",meal_plan$min[meal_plan$food_id == food]," and ",meal_plan$max[meal_plan$food_id == food],". Options: "),serve_range), collapse = " "))
      }
    } else{
      off_measures <- nutrients_diff[nutrients_diff$value != 0,]
      target_measure <- sample_safe(off_measures$nutrient)
      
      if(target_measure == 'alcohol_perc'){
        foods_impacted <- meal_plan$food_id[meal_plan$food_group == 'Alcohol']
      } else if(target_measure == 'discretionary_perc'){
        foods_impacted <-meal_plan$food_id[meal_plan$food_group == 'Discretionary foods']
      } else if(target_measure == 'takeaway_perc'){
        foods_impacted <-meal_plan$food_id[meal_plan$food_group == 'Takeaway']
      } else if(target_measure == 'redmeat'){
        foods_impacted <-meal_plan$food_id[meal_plan$redmeat == TRUE]
      } else if(target_measure == 'sodium'){
        foods_impacted <-meal_plan$food_id[meal_plan$sodium_mg > 0]
      } else if(target_measure == 'energy'){
        foods_impacted <-meal_plan$food_id[meal_plan$energy_kj_g > 0]
      } else{
        col <- target_measure
        if(grepl('perc', col)){
          col <- unlist(strsplit(col, '_perc',1))
        }
        col <- paste0(col, '_g')
        foods_impacted <- meal_plan$food_id[meal_plan[col] > 0]
      }
      if(length(foods_impacted) == 0){
        print(paste('No food impact measure:',target_measure))
        next
      }
      food <- sample_safe(foods_impacted)
      if(off_measures$value[off_measures$nutrient == target_measure] > 0){
        print(paste0('We are too high on ',target_measure,'. Current: ',nutrients_plan$value[nutrients_plan$nutrient == target_measure],'. Max: ',nutrient_targets_wk$max[nutrient_targets_wk$nutrient == target_measure]))
        serve_range <- sort(seq(meal_plan$min[meal_plan$food_id == food], meal_plan$intake[meal_plan$food_id == food], meal_plan$serve_size[meal_plan$food_id == food]*min_serve_size_difference))
        if(length(serve_range) > 10){
          serve_range <- tail(serve_range, 10)
        }
        iterations_constraints$high[iterations_constraints$nutrient == target_measure] <- iterations_constraints$high[iterations_constraints$nutrient == target_measure] + 1
      } else{
        print(paste0('We are too low on ',target_measure,'. Current: ',nutrients_plan$value[nutrients_plan$nutrient == target_measure],'. Min: ',nutrient_targets_wk$min[nutrient_targets_wk$nutrient == target_measure]))
        serve_range <- sort(seq(meal_plan$intake[meal_plan$food_id == food], meal_plan$max[meal_plan$food_id == food], meal_plan$serve_size[meal_plan$food_id == food]*min_serve_size_difference))
        if(length(serve_range) > 10){
          serve_range <- head(serve_range, 10)
        }
        iterations_constraints$low[iterations_constraints$nutrient == target_measure] <- iterations_constraints$high[iterations_constraints$nutrient == target_measure] + 1
      }
      print(paste0(paste0(c(paste0(meal_plan$food_name[meal_plan$food_id == food]," impacts ", target_measure, " and intake must be between ", meal_plan$min[meal_plan$food_id == food]," and ",meal_plan$max[meal_plan$food_id == food],". Options:"),serve_range), collapse = " "),". Current: ",meal_plan$intake[meal_plan$food_id == food]))
    }
    
    if(!is.null(serve_range)){
      new_intake <- sample_safe(serve_range)
      print(paste0('Changing ', meal_plan$food_name[meal_plan$food_id == food],' intake from ',meal_plan$intake[meal_plan$food_id == food],' to ',new_intake))
      meal_plan$intake[meal_plan$food_id == food] <- new_intake
    }
  }
  results <- list(path_file = paste0(abs_path, new_dir),
                  meals_created = length(hash_list),
                  last_meal = meal_plan,
                  iterations_constraints = iterations_constraints,
                  iterations_fg = iterations_fg,
                  iterations_lk = iterations_lk,
                  nutrients_diff = nutrients_diff,
                  serves_diff = serves_diff,
                  nutrient_targets_wk = nutrient_targets_wk,
                  food_groups_wk = food_groups_wk)
  return(results)
}

#' Exportation of Monte Carlo results
#' 
#' Exports, in .xlsx format, the results of Monte Carlo simulation.
#' @param results List of results
#' @param person Individual whose random meal plan will be created to. Can be one of man, woman, boy or girl.
#' @param diet Chosen diet. Must be DIETNAME from 'constraints_DIETNAME_diet_foods' sheet in dataset.
#' @param allowed_varieties Permitted food varieties. Can be a vector of the following: 1,2 and/or 3.
#' @param iterations Number of iterations. Integer.
#' @examples
#' printResults(results, person, diet, allowed_varieties, iterations)#' 
#' @export
printResults <- function(results, person, diet, allowed_varieties,iterations){
  general <- data.frame('Variable' = c('Individual', 'Diet', 'Varieties','Iterations', 'Hit meals', 'Path to hit meals'),
                        'Value' = c(person, diet, paste0(allowed_varieties, collapse = ","), iterations, results[['meals_created']], results[['path_file']]))
  
  write.xlsx(general,
             paste(paste('results',person,diet,format(Sys.time(), "%Y-%m-%d_%H-%M"),sep ='_'),'xlsx',sep = '.'),
             sheetName = 'General info',
             row.names= FALSE)
  write.xlsx(results[['nutrient_targets_wk']],
             paste(paste('results',person,diet,format(Sys.time(), "%Y-%m-%d_%H-%M"),sep ='_'),'xlsx',sep = '.'),
             sheetName = 'Weekly nutrients',
             append = TRUE,
             row.names = FALSE)
  write.xlsx(results[['food_groups_wk']],
             paste(paste('results',person,diet,format(Sys.time(), "%Y-%m-%d_%H-%M"),sep ='_'),'xlsx',sep = '.'),
             sheetName = 'Weekly serves',
             append = TRUE,
             row.names = FALSE)
  write.xlsx(results[['iterations_constraints']],
             paste(paste('results',person,diet,format(Sys.time(), "%Y-%m-%d_%H-%M"),sep ='_'),'xlsx',sep = '.'),
             sheetName = 'Iterations (nutrients)',
             append = TRUE,
             row.names = FALSE)
  write.xlsx(results[['iterations_fg']],
             paste(paste('results',person,diet,format(Sys.time(), "%Y-%m-%d_%H-%M"),sep ='_'),'xlsx',sep = '.'),
             sheetName = 'Iterations (food groups)',
             append = TRUE,
             row.names = FALSE)
  write.xlsx(results[['iterations_lk']],
             paste(paste('results',person,diet,format(Sys.time(), "%Y-%m-%d_%H-%M"),sep ='_'),'xlsx',sep = '.'),
             sheetName = 'Iterations (linked foods)',
             append = TRUE,
             row.names = FALSE)
  write.xlsx(as.data.frame(results[['last_meal']]),
             paste(paste('results',person,diet,format(Sys.time(), "%Y-%m-%d_%H-%M"),sep ='_'),'xlsx',sep = '.'),
             sheetName = 'Last meal created',
             append = TRUE,
             row.names = FALSE)
  write.xlsx(results[['nutrients_diff']],
             paste(paste('results',person,diet,format(Sys.time(), "%Y-%m-%d_%H-%M"),sep ='_'),'xlsx',sep = '.'),
             sheetName = 'Difference (nutrients)',
             append = TRUE,
             row.names = FALSE)
  write.xlsx(results[['serves_diff']],
             paste(paste('results',person,diet,format(Sys.time(), "%Y-%m-%d_%H-%M"),sep ='_'),'xlsx',sep = '.'),
             sheetName = 'Difference (serves)',
             append = TRUE,
             row.names = FALSE)
}

#' Single-function Monte Carlo simulation and results export.
#' 
#' Runs Monte Carlo Simulation and prints results, in .xlsx format, in a single funtion.
#' @param iterations Number of iterations. Integer.
#' @param foods_df Foods dataframe.
#' @param nutrient_targets_df Nutrient constraints dataframe.
#' @param food_group_targets_df Food group serves dataframe.
#' @param person Individual whose random meal plan will be created to. Can be one of man, woman, boy or girl.
#' @param diet Chosen diet. Must be DIETNAME from 'constraints_DIETNAME_diet_foods' sheet in dataset.
#' @param allowed_varieties Permitted food varieties. Can be a vector of the following: 1,2 and/or 3.
#' @param min_serve_size_difference Multiplier to serve difference. A float between 0 and 1.
#' @param allow_alcohol Boolean variable checking if alcohol is permitted. Default TRUE.
#' @param allow_discretionary Boolean variable checking if discretionary foods are permitted. Default TRUE.
#' @param allow_takeaway Boolean variable checking if takeaway is permitted. Default TRUE.
#' @param emission_cols Optional parameter. Emission column names if standard dataset isn't used.
#' @param nutrient_cols Optional parameter. Nutrients column names if standard dataset isn't used.
#' @param nutrient_constraints Optional parameter. Vector of nutrients column names to be used if not all nutrients are to be used as constraints.
#' @param linked_low_1 Optional parameter. Vector of lower bound food IDs.
#' @param linked_high_1 Optional parameter. Vector of higher bound food IDs.
#' @param linked_low_2 Optional parameter. Vector of lower bound food IDs.
#' @param linked_high_2 Optional parameter. Vector of higher bound food IDs.
#' @examples
#' monteCarloSimulation(100000, foods_df, nutrient_targets, food_groups_df, person = 'woman', 'PF', c(1,2,3), 0.5, allow_discretionary = TRUE, allow_alcohol = TRUE, allow_takeaway = TRUE, linked_low_1 = linked_bread_low, linked_high_1 = linked_bread_high, linked_low_2 = linked_milk_low, linked_high_2 = linked_milk_high)
#' 
#' @export

monteCarloSimulation <- function(iterations, foods_df, nutrient_targets_df, food_group_targets_df, person, diet, allowed_varieties, min_serve_size_difference, allow_discretionary = TRUE, allow_alcohol = TRUE, allow_takeaway = TRUE, emission_cols = NULL, nutrient_cols = NULL, nutrient_constraints = NULL, linked_low_1 = NULL, linked_high_1 = NULL, linked_low_2 = NULL, linked_high_2 = NULL){
  if((!is.null(linked_low_1) && is.null(linked_high_1))||(!is.null(linked_high_1) && is.null(linked_low_1))){
    stop('Please inform the matching pair of linked foods!')
  }
  if((!is.null(linked_low_2) && is.null(linked_high_2))||(!is.null(linked_high_2) && is.null(linked_low_2))){
    stop('Please inform the matching pair of linked foods!')
  }
  if((!is.null(linked_low_2)||!is.null(linked_high_2))&&(is.null(linked_low_1)&&is.null(linked_high_1))){
    stop('Please inform the first pair of linked foods!')
  }
  
  if(is.null(nutrient_cols)){
    nutrient_cols <- c('energy_kj_g','fat_g','sat_fat_g','CHO_g','sugars_g','fibre_g','protein_g','sodium_mg')
  }
  
  if(is.null(emission_cols)){
    emission_cols <- c('CF_gCO2eq', 'WF_l', 'EF_g_m2')
  }
  
  if(!is.null(nutrient_constraints)){
    for(i in 1:length(nutrient_constraints)){
      if(!(nutrient_constraints[i]) %in% nutrient_cols){
        stop('Nutrient constraints must also be located in nutrient values. Check your data!')
      }
    }
  }
  results <- monteCarlo(iterations, foods_df, nutrient_targets_df, food_group_targets_df, person, diet, allowed_varieties, min_serve_size_difference, allow_discretionary, allow_alcohol, allow_takeaway, emission_cols, nutrient_cols, nutrient_constraints, linked_low_1, linked_high_1, linked_low_2, linked_high_2)
  printResults(results, person, diet, allowed_varieties, iterations)
}

#'Calculates results for a Monte Carlo Simulation
#'
#'Calculates a confidence interval for several parameters obtained through a Monte Carlo Simulation. This function should be employed only if the standard table supplied with this package is utilized. Prints a .xlsx file in the home directory.
#'@param path_file A string containing the path to the folder containing the .csv files created in the monteCarlo function.
#'@param confidence_interval A float. Must be either 0.01, 0.05 or 0.1.
#'@examples
#'calculateResults('/my/folder', 0.05)
#'@export
calculateResults <- function(path_file, confidence_interval){
  if(!(confidence_interval %in% c(0.01, 0.05, 0.1))){
    stop('Confidence interval must be either 0.01, 0.05 or 0.1. Please try again!')
  }

  files <- list.files(path = path_file, pattern = "meal_plan_", all.files = FALSE,
                      full.names = FALSE, recursive = FALSE,
                      ignore.case = FALSE, include.dirs = FALSE, no.. = FALSE)
  
  if(lenght(files) == 0){
    stop("There aren't any files in said directory. Please try again.")
  } else{
    df <- data.frame(item = c('energy_kj_g', 'fat_g', 'sat_fat_g', 'CHO_g', 'sugars_g', 'protein_g', 'fat_perc', 'sat_fat_perc', 'CHO_perc', 'sugars_perc', 'fibre_g', 'protein_perc', 'red_meat_g', 'sodium_mg', 'fruit_serves', 'vegetable_serves', 'grains_serves', 'dairy_serves', 'protein_serves', 'fats_serves', 'sauces_serves', 'beverages_serves', 'ssb_serves', 'starchy_serves', 'red_meat_serves', 'alcohol_serves', 'discretionary_serves', 'fruit_perc', 'vegetable_perc', 'grains_perc', 'dairy_perc', 'protein_foods_perc', 'fats_perc', 'sauces_perc', 'beverages_perc', 'ssb_perc', 'starchy_perc', 'red_meat_perc', 'alcohol_perc', 'discretionary_perc', 'price', 'CF_gCO2eq', 'WF_l', 'EF_g_m2'))
    confidence_interval <- 1 - (confidence_interval/2)
    for(file in files){
      meal_df <- read.csv(file.path(path_file, file))
      col <- as.character(strsplit(file,'.csv')[1])
      df[,col] <- double(52)
      
      for(i in 1:nrow(df)){
        switch(df$item[i],
               'energy_kj_g' = {df[i, col] <- sum((meal_df$energy_kj_g/100)*meal_df$intake, na.rm = TRUE)},
               'fat_g' = {df[i, col] <- sum((meal_df$fat_g/100)*meal_df$intake, na.rm = TRUE)},
               'sat_fat_g' = {df[i, col] <- sum((meal_df$sat_fat_g/100)*meal_df$intake, na.rm = TRUE)},
               'CHO_g' = {df[i, col] <- sum((meal_df$CHO_g/100)*meal_df$intake, na.rm = TRUE)},
               'sugars_g' = {df[i, col] <- sum((meal_df$sugars_g/100)*meal_df$intake, na.rm = TRUE)},
               'protein_g' = {df[i, col] <- sum((meal_df$protein_g/100)*meal_df$intake, na.rm = TRUE)},
               'fat_perc' = {df[i, col] <- (sum((meal_df$fat_g/100)*meal_df$intake, na.rm = TRUE)*f1)/sum((meal_df$energy_kj_g/100)*meal_df$intake, na.rm = TRUE)*100},
               'sat_fat_perc' = {df[i, col] <- (sum((meal_df$sat_fat_g/100)*meal_df$intake, na.rm = TRUE)*f1)/sum((meal_df$energy_kj_g/100)*meal_df$intake, na.rm = TRUE)*100},
               'CHO_perc' = {df[i, col] <- (sum((meal_df$CHO_g/100)*meal_df$intake, na.rm = TRUE)*f2)/sum((meal_df$energy_kj_g/100)*meal_df$intake, na.rm = TRUE)*100},
               'sugars_perc' = {df[i, col] <- (sum((meal_df$sugars_g/100)*meal_df$intake, na.rm = TRUE)*f2)/sum((meal_df$energy_kj_g/100)*meal_df$intake, na.rm = TRUE)*100},
               'fibre_g' = {df[i, col] <- sum((meal_df$fibre_g/100)*meal_df$intake, na.rm = TRUE)},
               'protein_perc' = {df[i, col] <- (sum((meal_df$protein_g/100)*meal_df$intake, na.rm = TRUE)*f2)/sum((meal_df$energy_kj_g/100)*meal_df$intake, na.rm = TRUE)*100},
               'red_meat_g' = {df[i, col] <- sum(meal_df$intake[meal_df$food_group == 'red meat'], na.rm = TRUE)},
               'sodium_mg' = {df[i, col] <- sum((meal_df$sodium_mg/100)*meal_df$intake, na.rm = TRUE)},
               'fruit_serves' = {df[i, col] <- sum((meal_df$serves[meal_df$food_group == 'Fruit']), na.rm = TRUE)},
               'vegetable_serves' = {df[i, col] <- sum((meal_df$serves[meal_df$food_group == 'Vegetables']), na.rm = TRUE)},
               'grains_serves' = {df[i, col] <- sum((meal_df$serves[meal_df$food_group == 'Grains']), na.rm = TRUE)},
               'dairy_serves' = {df[i, col] <- sum((meal_df$serves[meal_df$food_group == 'Dairy/alternatives']), na.rm = TRUE)},
               'protein_serves' = {df[i, col] <- sum((meal_df$serves[meal_df$food_group == 'Protein foods: Meat, poultry, seafood, eggs, legumes, nuts, seeds']), na.rm = TRUE)},
               'fats_serves' = {df[i, col] <- sum((meal_df$serves[meal_df$food_group == 'Fats & oils']), na.rm = TRUE)},
               'sauces_serves' = {df[i, col] <- sum((meal_df$serves[meal_df$food_group == 'Sauces, dressings, spreads, sugars']), na.rm = TRUE)},
               'beverages_serves' = {df[i, col] <- sum((meal_df$serves[meal_df$food_group == 'Beverages']), na.rm = TRUE)},
               'ssb_serves' = {df[i, col] <- sum((meal_df$serves[meal_df$food_group == 'ssb']), na.rm = TRUE)},
               'starchy_serves' = {df[i, col] <- sum((meal_df$serves[meal_df$food_group == 'Starchy vegetables']), na.rm = TRUE)},
               'red_meat_serves' = {df[i, col] <- sum((meal_df$serves[meal_df$food_group == 'red meat']), na.rm = TRUE)},
               'alcohol_serves' = {df[i, col] <- sum((meal_df$serves[meal_df$food_group == 'Alcohol']), na.rm = TRUE)},
               'discretionary_serves' = {df[i, col] <- sum((meal_df$serves[meal_df$food_group == 'Discretionary foods']), na.rm = TRUE)},
               'fruit_perc' = {df[i, col] <- (sum((meal_df$energy_kj_g[meal_df$food_group == 'Fruit']/100)*(meal_df$intake[meal_df$food_group == 'Fruit']), na.rm = TRUE)/(sum((meal_df$energy_kj_g/100)*meal_df$intake, na.rm = TRUE)))*100},
               'vegetable_perc' = {df[i, col] <- (sum((meal_df$energy_kj_g[meal_df$food_group == 'Vegetables']/100)*(meal_df$intake[meal_df$food_group == 'Vegetables']), na.rm = TRUE)/(sum((meal_df$energy_kj_g/100)*meal_df$intake, na.rm = TRUE)))*100},
               'grains_perc' = {df[i, col] <- (sum((meal_df$energy_kj_g[meal_df$food_group == 'Grains']/100)*(meal_df$intake[meal_df$food_group == 'Grains']), na.rm = TRUE)/(sum((meal_df$energy_kj_g/100)*meal_df$intake, na.rm = TRUE)))*100},
               'dairy_perc' = {df[i, col] <- (sum((meal_df$energy_kj_g[meal_df$food_group == 'Dairy/alternatives']/100)*(meal_df$intake[meal_df$food_group == 'Dairy/alternatives']), na.rm = TRUE)/(sum((meal_df$energy_kj_g/100)*meal_df$intake, na.rm = TRUE)))*100},
               'protein_foods_perc' = {df[i, col] <- (sum((meal_df$energy_kj_g[meal_df$food_group == 'Protein foods: Meat, poultry, seafood, eggs, legumes, nuts, seeds']/100)*(meal_df$intake[meal_df$food_group == 'Protein foods: Meat, poultry, seafood, eggs, legumes, nuts, seeds']), na.rm = TRUE)/(sum((meal_df$energy_kj_g/100)*meal_df$intake, na.rm = TRUE)))*100},
               'fats_perc' = {df[i, col] <- (sum((meal_df$energy_kj_g[meal_df$food_group == 'Fats & oils']/100)*(meal_df$intake[meal_df$food_group == 'Fats & oils']), na.rm = TRUE)/(sum((meal_df$energy_kj_g/100)*meal_df$intake, na.rm = TRUE)))*100},
               'sauces_perc' = {df[i, col] <- (sum((meal_df$energy_kj_g[meal_df$food_group == 'Sauces, dressings, spreads, sugars']/100)*(meal_df$intake[meal_df$food_group == 'Sauces, dressings, spreads, sugars']), na.rm = TRUE)/(sum((meal_df$energy_kj_g/100)*meal_df$intake, na.rm = TRUE)))*100},
               'beverages_perc' = {df[i, col] <- (sum((meal_df$energy_kj_g[meal_df$food_group == 'Beverages']/100)*(meal_df$intake[meal_df$food_group == 'Beverages']), na.rm = TRUE)/(sum((meal_df$energy_kj_g/100)*meal_df$intake, na.rm = TRUE)))*100},
               'ssb_perc' = {df[i, col] <- (sum((meal_df$energy_kj_g[meal_df$food_group == 'ssb']/100)*(meal_df$intake[meal_df$food_group == 'ssb']), na.rm = TRUE)/(sum((meal_df$energy_kj_g/100)*meal_df$intake, na.rm = TRUE)))*100},
               'starchy_perc' = {df[i, col] <- (sum((meal_df$energy_kj_g[meal_df$food_group == 'Starchy vegetables']/100)*(meal_df$intake[meal_df$food_group == 'Starchy vegetables']), na.rm = TRUE)/(sum((meal_df$energy_kj_g/100)*meal_df$intake, na.rm = TRUE)))*100},
               'red_meat_perc' = {df[i, col] <- (sum((meal_df$energy_kj_g[meal_df$food_group == 'red meat']/100)*(meal_df$intake[meal_df$food_group == 'red meat']), na.rm = TRUE)/(sum((meal_df$energy_kj_g/100)*meal_df$intake, na.rm = TRUE)))*100},
               'alcohol_perc' = {df[i, col] <- (sum((meal_df$energy_kj_g[meal_df$food_group == 'Alcohol']/100)*(meal_df$intake[meal_df$food_group == 'Alcohol']), na.rm = TRUE)/(sum((meal_df$energy_kj_g/100)*meal_df$intake, na.rm = TRUE)))*100},
               'discretionary_perc' = {df[i, col] <- (sum((meal_df$energy_kj_g[meal_df$food_group == 'Discretionary foods']/100)*(meal_df$intake[meal_df$food_group == 'Discretionary foods']), na.rm = TRUE)/(sum((meal_df$energy_kj_g/100)*meal_df$intake, na.rm = TRUE)))*100},
               'price' = {df[i, col] <- sum((meal_df$price/100)*meal_df$intake, na.rm = TRUE)},
               'CF_gCO2eq' = {df[i, col] <- sum((meal_df$CF_gCO2eq/1000)*meal_df$intake, na.rm = TRUE)},
               'WF_l' = {df[i, col] <- sum((meal_df$WF_l/1000)*meal_df$intake, na.rm = TRUE)},
               'EF_g_m2' = {df[i, col] <- sum((meal_df$EF_g_m2/1000)*meal_df$intake, na.rm = TRUE)}
        )
        
      }
    }
    df_results <- data.frame(item = df$item)
    df_results[,c('value', 'margin')] <- double(nrow(df))
    
    for(i in 1:nrow(df)){
      n <- ncol(df) - 1
      df_results$value[i] <- as.numeric(rowMeans(df[i,2:ncol(df)]))
      s <- sd(df[i,2:ncol(df)])
      df_results$margin[i] <- ifelse(n <= 30,
                                     qt(confidence_interval,df=n-1)*s/sqrt(n),
                                     qnorm(confidence_interval)*s/sqrt(n))
      
    }
    
    df_results[nrow(df_results)+1,] <-c('n',n,NA)
    write_xlsx(df_results, file.path(getwd(), paste0('calculated_results_', format(Sys.time(), '%Y%m%d%H%M%S'), '.xlsx')))
  }
}


#'Calculates grouped results for a Monte Carlo Simulation
#'
#'Calculates a confidence interval for price and footprints obtained through a Monte Carlo Simulation, grouped by food groups. This function should be employed only if the standard table supplied with this package is utilized. Prints a .xlsx file in the home directory.
#'@param path_file A string containing the path to the folder containing the .csv files created in the monteCarlo function.
#'@param confidence_interval A float. Must be either 0.01, 0.05 or 0.1.
#'@examples
#'calculateGroupedResults('/my/folder', 0.05)
#'@export
calculateGroupedResults <- function(path_file, confidence_interval){
  if(!(confidence_interval %in% c(0.01, 0.05, 0.1))){
    stop('Confidence interval must be either 0.01, 0.05 or 0.1. Please try again!')
  }
  
  files <- list.files(path = path_file, pattern = "meal_plan_", all.files = FALSE,
                      full.names = FALSE, recursive = FALSE,
                      ignore.case = FALSE, include.dirs = FALSE, no.. = FALSE)
  
  if(lenght(files) == 0){
    stop("There aren't any files in said directory. Please try again.")
  } else{
    df <- data.frame(item = c('price', 'CF_gCO2eq', 'WF_l', 'EF_g_m2'))
    confidence_interval <- 1 - (confidence_interval/2)
    for(file in files){
      meal_df <- read.csv(file.path(path_file, file))
      col <- as.character(strsplit(file,'.csv')[1])
      df[,col] <- double(4)
      meal_df$price <- (meal_df$price/100)*meal_df$intake
      meal_df$CF_gCO2eq <- (meal_df$CF_gCO2eq/1000)*meal_df$intake
      meal_df$WF_l <- (meal_df$WF_l/1000)*meal_df$intake
      meal_df$EF_g_m2 <- (meal_df$EF_g_m2/1000)*meal_df$intake
      for(i in nrow(df)){
        switch(df$item[i],
               'price' = {df[i, col] <- meal_df %>% group_by(food_group) %>% summarise(!!col := sum(price, na.rm = TRUE)) %>% select(!!col)},
               'CF_gCO2eq' = {df[i, col] <- meal_df %>% group_by(food_group) %>% summarise(!!col := sum(CF_gCO2eq, na.rm = TRUE)) %>% select(!!col)},
               'WF_l' = {df[i, col] <- meal_df %>% group_by(food_group) %>% summarise(!!col := sum(WF_l, na.rm = TRUE)) %>% select(!!col)},
               'EF_g_m2' = {df[i, col] <- meal_df %>% group_by(food_group) %>% summarise(!!col := sum(EF_g_m2, na.rm = TRUE)) %>% select(!!col)}
        )
      }
    }
    df_results <- data.frame(item = df$item)
    df_results[,c('value', 'margin')] <- double(nrow(df))
    
    for(i in 1:nrow(df)){
      n <- ncol(df) - 1
      df_results$value[i] <- as.numeric(rowMeans(df[i,2:ncol(df)]))
      s <- sd(df[i,2:ncol(df)])
      df_results$margin[i] <- ifelse(n <= 30,
                                     qt(confidence_interval,df=n-1)*s/sqrt(n),
                                     qnorm(confidence_interval)*s/sqrt(n))
      
    }
    df_results[nrow(df_results)+1,] <-c('n',n,NA)
    write_xlsx(df_results, file.path(getwd(), paste0('calculated_results_', format(Sys.time(), '%Y%m%d%H%M%S'), '.xlsx')))
    }

}